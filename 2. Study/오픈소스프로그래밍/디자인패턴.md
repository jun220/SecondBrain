소프트웨어 디자인 과정에서 자주 발생하는 문제들에 대한 전형적인 해결책. 비슷한 문제들을 해결하기 위해 공통적으로 적용할 수 있는 best practice (청사진)

알고리즘과는 다르게 결과와 기능들은 제시하나, 구현 단계 및 순서는 사용자가 결정하도록 함.

### 디자인 패턴의 필요성
- 다른 사람의 경험을 활용해 더 효율적으로 개발할 수 있음
- 소프트웨어 설계 방법론을 자연스럽게 적용할 수 있음
- 설계 과정의 속도를 높일 수 있음
- 재사용성이 높고, 변경이 쉬움
- 복잡한 구조를 합의된 용어로 설명할 수 있어 의사 소통이 효율적

ex> GoF의 디자인 패턴
- 객체지향 개념에 따른 설계 중에서, 재사용할 경우에 유용한 것을 정립한 것
- 너무 일반적이지도 구체적이지도 않은 형태로, 소프트웨어 설계를 위한 지식이나 노하우를 공유할 수 있음

### 디자인 패턴에 대한 비판
- 좋은 프로그래밍 언어에는 필요성이 적음
	- 일반적으로 패턴의 필요성은, 개발자가 추상화 수준이 부족한 프로그래밍 언어나 기술을 선택했을 때 발생
- 비효율적인 해결책
	- 패턴을 프로젝트의 맥락에 따라 적용하지 않고, '문자 그대로' 구현할 경우 비효율적일 수 있음
- 부당한 사용
	- 더 간단한 코드로도 문제 해결을 할 수 있는 상황에도 모든 곳에 패턴을 적용하려고 함

## 객체지향
객체지향개발은 아래 4가지 특성을 지켜야 함
추상화 | 캡슐화 | 상속성 | 다형성

객체지향설계 원칙 (SOLID)
- 단일 책임 원칙 (Single Responsibility)
- 개방-폐쇄 원칙 (Open Closed)
- 리스코프 치환 원칙 (Liskov Substitution)
- 인터페이스 분리 (Interface Segregation)
- 의존 역전 (Dependency Inversion)

#### 추상화
클래스들의 공통적인 특성을 묶어서 표현하는 것. 여기서 특성은 특징을 나타내는 변수, 행위를 나타내는 메서드가 있다고 생각할 수 있음.
![[Pasted image 20241213152936.png]]

예시: 휴대폰
휴대폰의 공통적 특징
- 마이크, 스피커를 가지고 있음
- 디스플레이를 가지고 있음
휴대폰의 공통적 행위
- 마이크, 스피커로 통화기능 제공
- 디스플레이를 통해 유저 인터페이스 제공

이러한 특징과 행위를 묶어서 휴대폰 클래스를 만들 수 있음, 이를 추상화라고 함.

#### 캡슐화
데이터와 코드의 형태를 외부로부터 알 수 없게 하고, 데이터의 구조와 역할, 기능을 하나의 캡슐 형태로 만드는 것.
private, 혹은 protected를 이용해 보호하고 싶은 인자를 보호하고, 프로그래머가 짜 놓은 방식으로만 사용하게 만든 것.

![[Pasted image 20241213153043.png]]
Connect() 함수와 멤버 변수들은 외부에 노출될 필요가 없으므로 모두 private으로 관리하고 있음.

#### 상속성
부모 클래스에 정의된 변수 및 메서드를 자식 클래스에서 상속받아 사용하는 것
클래스를 정의할 때, 기존에 있던 클래스를 확장해서 파생. 다형성을 실현하는데 필수적인 요소
![[Pasted image 20241213153155.png]]

부모클래스에 protected로 선언된 정보는 자식 클래스에서 접근 지정자를 확장할 수 있음. private과 달리, 자식 클래스는 protected에 접근할 수 있으므로, 이를 public으로 만들 수 있는것.

이렇게 접근 지정자는 확장될 수 있으나, 축소하는 것은 원칙적으로 허용되지 않음

![[Pasted image 20241213153449.png]]

**주의할 점**
상속관계의 클래스를 정의할 때 각 클래스의 기능을 명확히 분류해야 함. 제대로 분리하지 못하면 상속의 의미가 퇴색되고, 가독성이 떨어짐.

다중상속을 잘못 사용하면 상속하고자 하는 대상이 애매해짐

#### 다형성
다양한 형태로 표현이 가능한 구조라는 뜻.
오버라이딩과 오버로딩을 통해 실현할 수 있음.

**오버로딩**: 같은 이름에, 패러미터가 다른 메서드를 여러개 만드는 것.

**오버라이딩**: 같은 이름의 메서드가, 어떤 파생 클래스인지에 따라 동작이 달라지는 것.
매개변수와 리턴타입이 모두 동일해야 함

**정적 바인딩** (오버로딩)
- 실행 이전에 값이 확정
- 컴파일 타임에 호출될 함수가 결정되는 것
- 값이 변하지 않아서 안정적이고 효율적이지만, 유연하지 않음

**동적 바인딩** (오버라이딩)
- 실행 이후에 값이 확정
- 런타임에 호출될 함수가 결정되는 것
- 조금 느리지만 유연함
- virtual 키워드를 사용한 가상 메서드와 관련됨

### 객체지향설계 원칙
![[Pasted image 20241213154522.png]]

#### 단일 책임 원칙
각 클래스는 한가지 역할만 담당하고, 변경해야하는 이유는 단 하나여야 한다.
하나의 클래스가 둘 이상의 역할을 하고있다면, 별개의 클래스로 나누는 것이 좋다.
![[Pasted image 20241213154633.png]]
클래스는 하나의 책임을 완전히 캡슐화해야한다는 것


#### 개방-폐쇄 원칙
클래스는 확장에는 열려있고, 수정에는 닫혀있어야 한다.

기존에 있던 메서드를 수정하기보다, 추가적인 메서드를 만들라는 것. 오버로딩을 활용해 같은 이름에 패러미터만 다른 것을 추가할 수도 있고, 새로운 이름의 메서드를 만들어도 됨.

![[Pasted image 20241213154827.png]]
video player를 구현할 때 개방 폐쇄 원칙을 따르지 않으면, 지원하는 파일 형식이 추가될 때마다 계속 클래스를 수정해야 함

#### 리스코프 치환 원칙
상위 클래스의 객체는, 언제나 하위 클래스의 객체로 변경될 수 있어야 함.

여기서 상위클래스: 부모, 하위클래스: 자식.
부모 클래스 객체가 들어갈 자리에 자식 클래스 객체를 넣어도 괜찮다는 소리인데, 상속하는 과정에서 기존 기능을 파괴하지 않아야 한다는 뜻이다.
![[Pasted image 20241213203545.png]]

펭귄은 날 수 없으므로, 기존에 있던 fly기능이 파괴되었다.
재정의를 할 때는 상위 클래스의 책임을 무시하지 말아야 하고, 확장만 수행해야 한다.












