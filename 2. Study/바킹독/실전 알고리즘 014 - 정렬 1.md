```vid
https://youtu.be/59fZkZO0Bo4?si=VKmAkkGlvfpar96x
```

학습일 : 2025-02-19 20:20

---
## 학습내용

사실 코딩 테스트에서는 STL에서 제공하는 기존 sort 말고 다른 정렬을 사용할 일이 거의 없다. 정렬 알고리즘을 공부하는 것은 배경 지식이나, 면접 대비용이라고 생각해도 된다.

### 기초 정렬

가장 기본적인 정렬 방법을 생각했을 때, 아래와 같은 방법이 대표적이다.

1. 가장 크거나 작은 것을 맨 끝으로 보낸다.
2. 방금 보낸걸 제외한 나머지 중에서 가장 크거나 작은 것을 끝으로 보낸다.
3. 반복한다.

이는 **선택 정렬**로, 아래와 같은 코드로 구현할 수 있다.

```c++ title:"선택 정렬" fold
 int arr[10] = { 3, 2, 7, 116, 62, 235, 1, 23, 55, 77 };
 int N = 10;

 int minIndex = 0;
 for (int i = 0; i <= N - 1; i++) {
     minIndex = i;
     for (int j = i + 1; j < N; j++) {
         if (arr[j] < arr[minIndex]) minIndex = j;
     }

     swap(arr[i], arr[minIndex]);
 }
```

**버블 정렬**도 아이디어가 매우 간단한 편이다.
1. 왼쪽 끝부터 마지막 원소까지, 인접한 두 값을 비교하며, 왼쪽이 더 크다면 스왑한다.
2. 맨 끝 원소를 제외하고, 왼쪽 끝부터 마지막 원소까지 반복한다.

인접한 원소를 계속해서 비교하다보면, 결국은 완전히 정렬된 배열을 얻을 수 있다.

```c++ title:"버블 정렬" fold
for (int i = 0; i < N; i++) {
	for (int j = i; j < N-i-1; j++) {
		if (arr[j] > arr[j+1]) swap(arr[j], arr[j+1]);
	}
}
```
**선택 정렬**, **버블 정렬**, **선택 정렬**은 대표적인 정렬 알고리즘들로, 시간 복잡도는 모두 O(N<sup>2</sup>)이다. 시간 복잡도가 크기 때문에 실용적으로 활용하기는 힘들다.

### Merge Sort

재귀적으로 수열을 나눠 정렬한 후 합치는 정렬법. 시간복잡도는 O(NlogN)

먼저 이미  정렬되어 있는 두 배열을 합쳐서 정렬하는 과정에 대해 생각해 보자. 각 배열은 이미 정렬된 상태이다.
![[Pasted image 20250220005721.png]]
새로 만들어질 배열의 첫번째 원소로 결정하기 위해서는, 두 배열의 가장 작은 원소인 -9와 -7을 비교하면 된다.


![[Pasted image 20250220005731.png]]
-9가 선택되었으니, 이제는 남은 1과 -7을 비교한다. 이런식으로 두 배열에 cur를 하나씩 두고, 선택될 경우 cur를 증가시키면서 배열을 하나씩 합치면 될 것이다.

### 연습 문제 1 - 백준 11728
https://www.acmicpc.net/problem/11728
![[Pasted image 20250220010202.png]]

```c++ fold title:"내가 작성한 코드"
int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N, M;
    cin >> N >> M;
    list<int> A;
    list<int> B;
    list<int> C;

    int temp;

    for (int i = 0; i < N; i++) {
        cin >> temp;
        A.push_back(temp);
    }
    for (int i = 0; i < M; i++) {
        cin >> temp;
        B.push_back(temp);
    }


    auto curA = A.begin();
    auto curB = B.begin();

    while (curA != A.end() && curB != B.end()) {
        if (*curA < *curB) {
            C.push_back(*curA);
            curA++;
        }
        else {
            C.push_back(*curB);
            curB++;
        }
    }

    while (curA != A.end()) {
        C.push_back(*curA);
        curA++;
    }

    while (curB != B.end()) {
        C.push_back(*curB);
        curB++;
    }

    for (int n : C) {
        cout << n << ' ';
    }


}
```

이를 활용해서 머지 소트를 만들 수 있는데, 전체 배열을 쪼개고 쪼개서 크기 1짜리 배열로 만들고, 이들을 머지하며 정렬해 나가는 것이다.

![[Pasted image 20250220021252.png]]
이 코드를 보고 완성할 수 있도록 작성해보자.



---
### 태그
#코딩테스트 #cpp #자료구조



