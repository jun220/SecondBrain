```vid
https://youtu.be/Enz2csssTCs?si=Hzyw_nAedHpNie60
```

학습일 : 2025-01-31 21:03

---
### 학습내용
백트래킹: 현재 상태에서 가능한 모든 후보군을 따라 들어가며 탐색하는 알고리즘
상태를 넘나들기 때문에, 현재 어떤 상태에 있는지 기록하고 관리하는 것이 중요.

### 연습문제 1 - 백준 15649
https://www.acmicpc.net/problem/15649
![[Pasted image 20250131235511.png]]
예를 들어 4 3이 입력되면, 아래와 같이 출력하는 식이다.
```
1 2 3
1 2 4
1 3 2
1 3 4
...
```


![[Pasted image 20250131235356.png]]
별은 현재 상태를 의미. 1을 먼저 채운 상태로 시작. 이제 두번째 원소로는 2, 3, 4가 가능한 상황.

![[Pasted image 20250131235607.png]]
![[Pasted image 20250131235718.png]]
위와 같이 두번째 원소는 2, 마지막 원소는 3을 채웠다고 하자. 이제 수열이 완성되었으니 출력하고, 이전 상태로 돌아가야 한다.

![[Pasted image 20250131235653.png]]
다시 돌아가서, 이미 3은 확인 했으니, 4를 채워보자.
![[Pasted image 20250131235758.png]]
이제 다시 `1 2 _`의 상태로 돌아갔다가, 이제는 `1 3 _`의 상태로부터 새로 수열을 채우는 것이다.

![[Pasted image 20250131235949.png]]
백트래킹의 첫 인상은 트리에서 dfs 탐색을 돌리는 것과 매우 유사하다는 것이다. 그럼 백트래킹도 큐와 재귀를 이용해서 구현하게 될까?

![[Pasted image 20250201000200.png]]
내가 이해한대로 주석을 달아본 버전
```c++ title="백트래킹 연습" fold
void backtrack(int depth) {
    // 마지막 depth에 도착했다면, 그러니까 수열이 완성되었다면
    if (depth == M) {
        for (int i = 0; i < M; i++) {
            cout << arr[i] << ' ';
        }
        cout << '\n';
        return; // 재귀 종료
    }

    for (int i = 1; i <= N; i++) {
        // 사용하지 않은 숫자를 탐색
        if (!isused[i]) {
            // arr[depth]를 채움
            arr[depth] = i;

            // 사용 처리
            isused[i] = true;
            
            
            // 다음 depth에 대한 작업 시작
            backtrack(depth + 1);
            
            // i=1로부터 시작되었다고 생각하자
            // 이제 1로 시작하는 수열은 모두 작성했다는 뜻이다. 다시 원점으로 돌아온 것.
            // 이제 2로 시작하는 수열을 만들 차례. 따라서 1에 대한 isused는 초기화해야 한다.
            isused[i] = false;
        }
    }
}
```

### 연습문제 2 - N-Queen
https://www.acmicpc.net/problem/9663
![[Pasted image 20250201003506.png]]
N x N 체스판에 퀸 N개를 두는데, 퀸끼리 서로 공격할 수 없는 위치에 배치해야하는 문제다.
백트래킹을 이용하면 이 경우의 수가 몇가지인지 구할 수 있다.

![[Pasted image 20250201011811.png]]
A행, B행, C행, D행 순서대로 퀸을 하나씩 배치하면서 얼마나 가능한지 백트래킹을 확인하는 것이다.D3나 D2처럼 D행에 도착하는데 성공하면, 가능한 N-Queen 가짓수를 하나 찾았다고 생각할 수 있다.

그런데 문제는, 해당칸이 퀸을 놓을 수 있는 곳인지 어떻게 확인해야하냐는 것이다. 퀸을 배치할때, 이 퀸의 공격영역을 추가해주면 되지 않을까? 공격영역 관리하는 배열도 하나 만들고.

그렇게 해서 시도해 봤는데, 우선 결론적으로 실패했다. 내가 구현한 방법은 아래와 같았다.
1. 퀸을 배치할 때마다, 보드 전체에 대해 퀸의 공격경로를 계산하여 isUsed 처리를 한다
2. 다음 퀸을 배치한다. isUsed를 확인하여, 기존에 있는 퀸의 공격 반경에 들어가지 않도록 한다/
3. 백트래킹이 돌아오면, isUsed 처리를 철회하고 다른 위치에 퀸을 둔다.

**N과 M** 문제에서 했던 것과 같은 아이디어로 처리하기로 했던 것이다. 그런데 첫번째로 겪은 문제는 isUsed를 어떻게 철회할지였다. 수열을 하나씩 출력하는 문제에서는, isUsed를 true나 false로 바꿔주기만 하면 해결됐다. 그런데 이 문제에서는 퀸 두기를 철회할때마다, 그 퀸의 공격 범위를 모두 제외할 수 없다. 그 칸이 다른 퀸의 공격 범위 안에 들어갈 수도 있기 때문이다.

이를 해결하기 위해, 퀸을 둘 때마다 공격범위 칸에 1을 더하고, 퀸을 철회할 때마다 공격범위 칸에서 1을 빼주기로 했다. 칸이 0이면 어떤 퀸으로부터도 안전한 위치이고, 1 이상이라면 누군가의 공격범위인 것이다.

그런데도 이렇게 해서 정답을 얻어낼 수 없었는데, 이유는 다음과 같았다.
1. 시간이 너무 오래걸린다.
퀸의 공격범위를 간단히 계산하기 위해서 보드 전체를 순회하며 조건을 확인하는 식으로 짰는데, 이게 누적되면 매우 많은 시간을 피룡로 하는 것 같았다.

1. 순서를 고려해버린다.
특정 위치 a, b, c, d에 퀸을 둔다고 할때 `d, a, c, b`, `a, b, d, c` 등 순서만 다른 것도 퀸을 배치할 수 있는 새로운 방법으로 계산하고 있었다. 

여기까지 노력해 본 뒤, 난 강의영상을 확인하고 어떻게 문제를 풀어야하는지 확인했다. 실제 풀이는 **N과 M** 문제와 오히려 더 가까웠다.

우선은 col이나 row중 하나를 기준으로 잡고, 퀸을 하나씩 배치하는 것으로 시작한다. 한 줄에는 퀸이 하나씩밖에 올 수 없으니 당연한 시작점이다. 문제가 룩 배치였다면 여기서 문제가 끝났을 것이다.

이제 퀸의 대각선 이동을 어떻게 처리할지인데, 사실 체스판은 x와 y축으로만으로도 표현할 수 있지만, 대각선도 하나의 줄로 생각할 수 있다. 좌측 위에서 시작하는 대각선과, 우측 위에서 시작하는 대각선 두개를 추가로 고려하고, 이 대각선에도 한 줄에 하나씩만 올 수 있게 하는 것이다.

퀸을 배치할 때마다, 이 퀸이 4개의 줄에 대해 몇번에 위치하는지 isUsed 처리를 해주면 될 것 같다.






---
### 태그
#코딩테스트 #cpp #알고리즘 #재귀 #백트래킹




