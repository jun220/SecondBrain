```vid
https://youtu.be/Enz2csssTCs?si=Hzyw_nAedHpNie60
```

학습일 : 2025-01-31 21:03

---
### 학습내용
백트래킹: 현재 상태에서 가능한 모든 후보군을 따라 들어가며 탐색하는 알고리즘
상태를 넘나들기 때문에, 현재 어떤 상태에 있는지 기록하고 관리하는 것이 중요.

### 연습문제 1 - 백준 15649
https://www.acmicpc.net/problem/15649
![[Pasted image 20250131235511.png]]
예를 들어 4 3이 입력되면, 아래와 같이 출력하는 식이다.
```
1 2 3
1 2 4
1 3 2
1 3 4
...
```


![[Pasted image 20250131235356.png]]
별은 현재 상태를 의미. 1을 먼저 채운 상태로 시작. 이제 두번째 원소로는 2, 3, 4가 가능한 상황.

![[Pasted image 20250131235607.png]]
![[Pasted image 20250131235718.png]]
위와 같이 두번째 원소는 2, 마지막 원소는 3을 채웠다고 하자. 이제 수열이 완성되었으니 출력하고, 이전 상태로 돌아가야 한다.

![[Pasted image 20250131235653.png]]
다시 돌아가서, 이미 3은 확인 했으니, 4를 채워보자.
![[Pasted image 20250131235758.png]]
이제 다시 `1 2 _`의 상태로 돌아갔다가, 이제는 `1 3 _`의 상태로부터 새로 수열을 채우는 것이다.

![[Pasted image 20250131235949.png]]
백트래킹의 첫 인상은 트리에서 dfs 탐색을 돌리는 것과 매우 유사하다는 것이다. 그럼 백트래킹도 큐와 재귀를 이용해서 구현하게 될까?

![[Pasted image 20250201000200.png]]
내가 이해한대로 주석을 달아본 버전
```c++ title="백트래킹 연습" fold
void backtrack(int depth) {
    // 마지막 depth에 도착했다면, 그러니까 수열이 완성되었다면
    if (depth == M) {
        for (int i = 0; i < M; i++) {
            cout << arr[i] << ' ';
        }
        cout << '\n';
        return; // 재귀 종료
    }

    for (int i = 1; i <= N; i++) {
        // 사용하지 않은 숫자를 탐색
        if (!isused[i]) {
            // arr[depth]를 채움
            arr[depth] = i;

            // 사용 처리
            isused[i] = true;
            
            
            // 다음 depth에 대한 작업 시작
            backtrack(depth + 1);
            
            // i=1로부터 시작되었다고 생각하자
            // 이제 1로 시작하는 수열은 모두 작성했다는 뜻이다. 다시 원점으로 돌아온 것.
            // 이제 2로 시작하는 수열을 만들 차례. 따라서 1에 대한 isused는 초기화해야 한다.
            isused[i] = false;
        }
    }
}
```

### 연습문제 2 - N-Queen
https://www.acmicpc.net/problem/9663
![[Pasted image 20250201003506.png]]
N x N 체스판에 퀸 N개를 두는데, 퀸끼리 서로 공격할 수 없는 위치에 배치해야하는 문제다.
백트래킹을 이용하면 이 경우의 수가 몇가지인지 구할 수 있다.

![[Pasted image 20250201011811.png]]
A행, B행, C행, D행 순서대로 퀸을 하나씩 배치하면서 얼마나 가능한지 백트래킹을 확인하는 것이다.D3나 D2처럼 D행에 도착하는데 성공하면, 가능한 N-Queen 가짓수를 하나 찾았다고 생각할 수 있다.

그런데 문제는, 해당칸이 퀸을 놓을 수 있는 곳인지 어떻게 확인해야하냐는 것이다. 퀸을 배치할때, 이 퀸의 공격영역을 추가해주면 되지 않을까? 공격영역 관리하는 배열도 하나 만들고.

그렇게 해서 시도해 봤는데, 우선 결론적으로 실패했다. 내가 구현한 방법은 아래와 같았다.
1. 퀸을 배치할 때마다, 보드 전체에 대해 퀸의 공격경로를 계산하여 isUsed 처리를 한다
2. 다음 퀸을 배치한다. isUsed를 확인하여, 기존에 있는 퀸의 공격 반경에 들어가지 않도록 한다/
3. 백트래킹이 돌아오면, isUsed 처리를 철회하고 다른 위치에 퀸을 둔다.

**N과 M** 문제에서 했던 것과 같은 아이디어로 처리하기로 했던 것이다. 그런데 첫번째로 겪은 문제는 isUsed를 어떻게 철회할지였다. 수열을 하나씩 출력하는 문제에서는, isUsed를 true나 false로 바꿔주기만 하면 해결됐다. 그런데 만약 퀸 두기를 철회할때마다, 그 퀸의 공격 범위를 모두 






---
### 태그
#코딩테스트 #cpp #알고리즘




