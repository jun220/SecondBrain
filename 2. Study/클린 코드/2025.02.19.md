# 📚 Clean Code TIL (2025-02-19)

## 📖 읽은 범위

- 3장 **함수** (p.40 ~ {{page_end}})

## 📌 주요 개념

- 프로그램의 모든 기본단위는 함수이다.
- 함수는 간단하고 명료하게 작성되어야 한다.

## 📖 공부한 내용

프로그래밍 초창기에는 프로그램, 하위 프로그램, 함수가 있었으나, 현재는 함수만 남았다. 그리고 함수는 모든 프로그램의 가장 기본적인 단위다.

함수는 작고 명시적이어야 한다. 함수의 이름을 통해 이 함수의 동작을 명확히 파악할 수 있어야 하고, 함수의 동작 역시 단순해야 한다.

### 함수는 한 가지를 위해 존재해야 한다

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다. (p.44)

함수에서 일어나는 동작은, 어떻게 보느냐에 따라 한 개의 동작으로 묶일 수도, 여러 개의 동작으로 나뉠 수도 있다. 이를 판단하기 위해서는, <u>지정된 함수 이름 아래에서 추상화 수준이 하나인지</u> 확인해보라.

> 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다. (p.45)

함수 하나에서 일어나는 모든 동작은 같은 수준의 추상화 단계를 가지고 있어야 한다. `getHtml()`과 같이 복잡한 내부 구조를 가지고 있을 동작은 추상화 수준이 높다. 하지만 `.append('\n')`과 같은 코드는 훨씬 추상화 수준이 낮다고 할 수 있다.

함수가 '한 가지' 작업만 하고 있는지 판단하려면, <u>한 함수에서 의미 있는 이름으로 다른 함수를 추출할 수 있는지</u> 확인해보라. 만약 가능하다면, 그 함수는 여러 작업을 하고 있다고 볼 수 있다.

### 내려가기 규칙

함수 내부에서 다른 함수를 호출하는 일이 잦은데, 이 때 <u>호출하는 함수</u> 는, <u>호출되는 함수</u>보다 추상화 수준이 낮아야 한다는 것이다. 이를 **내려가기 규칙**이라고 한다.

이렇게 함수 추상화 수준이 한 단계씩 낮아져야 코드가 위에서 아래로 자연스럽게 읽힌다.

### 함수 명명 규칙

함수의 이름은 **서술적**이어야 한다. 함수가 하는 일을 제대로 표현할 수 있어야 하고, 이를 위해서는 함수의 이름이 길어져도 괜찮다. 짧고 모호한 함수 이름과 주석을 사용하는 것보다, 정확하고 긴 함수 이름을 사용하자.

또 함수의 이름은 일관성을 유지해야 한다. 예를 들어 초기화 역할을 하는 함수의 이름을 지을 때, 'setup', 'initialize', 'start' 등의 동사를 모두 사용한다면 혼란스러울 것이다.

모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용해야 한다. 
- includeSetupAndTeardownPages
- includeSetupPages
- includeSuiteSetupPage
- includeSuiteSetupPage

### 함수 인수

> 함수에서 이상적인 인수 개수는 0개다. 다음은 1개고, 다음은 2개다. 3개는 가능한 피하는 편이 좋다. (p.50)

함수에 지나치게 많은 인수를 넘기지 않도록 주의해야 한다. 3-4개 이상의 인수가 필요하다면 지나치게 많은 인수를 사용한 것이다.

인수를 적게 사용하면 함수를 읽기 쉽고 동작이 명확해진다. 또 테스트 관점에서 인수가 많으면, 유효한 값으로 모든 조합을 구성해 테스트하기 부담스러워진다.

출력인수는 더 문제가 된다. 리턴 값은 함수가 끝날 때 반환하는 값이지만, 출력 인수는 함수 실행 중에 전달된 <u>참조(reference)</u>나 <u>포인터(pointer)</u>를 통해 함수 외부로 값을 수정해서 전달하는 방식이다.

<u>함수를 호출한 곳</u>에 결과를 반환한다는 공통점은 있지만, 기본적으로 함수는 출력을 통해 결과를 반환해야 한다. 이런 방식은 코드를 다시 읽게 만든다.


- **리턴 값** (Return Value)
```cpp
int add(int a, int b) {
    return a + b;
}
// 함수는 a와 b를 더한 값을 리턴
int result = add(3, 4);  // result는 7이 된다

```
- **출력 인수** (Output Argument)
```cpp
void add(int a, int b, int& result) {
    result = a + b;
}
// 함수는 결과값을 반환하지 않고, result라는 출력 인수를 통해 값을 수정
int result;
add(3, 4, result);  // result는 7이 된다

```

#### 단항 함수

함수에 인수 1개를 넘기는 경우는 아래 두 가지가 대표적이다.
1. 질문을 던지는 경우
	- `boolean fileExits("MyFile")`
2. 인수를 변환해 결과를 반환하는 경우
	- `InputStream fileOpen("MyFile")`

드물게 사용하지만, **이벤트 함수**도 있다. 이벤트 함수는 입력 인수만 있고, 출력 인수는 없다. 이벤트 함수를 호출하는 것은 이벤트로 해석되어, 입력 인수로 시스템 상태를 바꾼다. 
- `passwordAttemptFailedNtimes(int attempts)`

이벤트 함수는 이름과 문맥을 통해 이벤트라는 사실을 코드에 명확히 드러내야 한다.

이외의 상황에서는 단항 함수도 피하는 것이 좋다. 특히 출력 인수를 사용하는 것은 삼가고, 반환 값으로 결과를 받을 수 있도록 해라.

**플래그 인수** 역시 사용하지 않아야 한다. 함수로 bool 값을 넘겨 이에 따라 다른 동작을 수행하게 하는 경우가 있는데, 이는 함수가 여러 가지를 처리한다는 의미가 된다.

앞에서 말했듯, 함수는 한 가지 역할만 수행해야 한다. 플래그 인수를 통해 두 가지 동작을 하게 만들 계획이었다면, 이 둘을 별도의 함수로 만들어라.

`render(boolean isSuite)`가 아니라, `renderForSuite()`와 `renderForSingleTest()`라는 두개의 함수를 만들어라.

#### 두개 이상의 인수를 가지는 함수

==이항함수==
함수에 두 개의 인수를 넘길 때, 두 인수는 **한 값을 표현하는 두 인수**거나, 인수 사이에 **자연적인 순서**가 있으면 좋다. 예를들어 `assertEquals(expected, actual)` 함수에서, expected와 actual에는 자연적인 순서가 없다.

==삼항함수==
인수가 3개가 되면, 이항함수보다도 훨씬 모호해진다. 매번 함수를 볼때마다 주춤할 수 있으니, 최대한 사용하지 말자.

인수가 2-3개가 필요하다면, 일부를 독자적인 클래스 변수로 선언하는 것이 더 좋을 수 있다. 
- `Circle makeCircle(double x, double y, double radius)`
- `Circle makeCircle(Point center, double radius)`

이렇게 변환해도 좋은 것은, x와 y가 결국 한 Point를 표현하고 있기 때문이다. 개념적으로 묶을 수 있는 인수가 있을때는 이렇게 적극적으로 묶어보자.

함수 이름에 키워드를 넣어서 인수 순서를 명확히 할 수도 있다. `assertEquas`보다 `assertExpectedEqualsActual`이 더 좋다.

==가변 함수==
`String.format("%s worked %.2f hours.", name, hours)`처럼, format 함수는 항의 개수가 가변적이다. 하지만 format의 두 번째 이후 인수들은 모두 첫번째 문자열을 대치할 요소로, 같은 기능을 수행하고 있다. 이 동등한 인수들을 하나의 list라고 생각한다면, 결국 format 함수는 이항 함수가 되는 것이다. 

이처럼 모든 가변 함수는 단항, 이항, 삼항 함수로 취급할 수 있다. 이를 넘어서는 인수가 필요하다면 문제가 있는 것이다.

### 부수 효과를 일으키지 마라

함수에서 정해진 동작을 하는 과정에서, 다른 일을 해서는 안된다. 이는 예상치 못한 결과로, **시간적인 결합**이나 **순서 종속성**을 초래한다.

### 결론

함수를 처음 짤 때는 길고 복잡하며, 들여 쓰기 단계도 많고 인수 목록도 길 수 있다. 이 시점에서 단위 테스트 케이스를 만들어, 우선 이 함수가 의도대로 동작하는지 검증한다. 하지만 이렇게 만들어진 초기 함수는 꼭 정돈이 필요하다. 

함수를 분리하며 명확한 이름을 지어보고, 클래스 구조를 바꿔가며  코드를 다듬는다. 새로 바뀐 구조에 맞춰 단위 테스트를 다시 실시한다.

이 규칙들을 활용해 **짧고, 이름이 좋고, 체계가 잡힌** 함수를 만들 수 있다. 하지만 진짜 목표는, 이렇게 잘 만들어진 함수를 이용해 프로그램을 잘 서술하는데 있다. 함수는 도구일 뿐이다.

## 💡 깨달은 점

함수를 분리해 코드를 작성하는 일이 많았고, 기존에도 이 작업을 꽤 잘 하고 있다고 생각했다. 그런데 클린 코드의 함수 파트를 읽어보니, 내가 놓치거나 잘못 생각한 개념이 많았던 것 같다.

대표적으로 **플래그 인수**를 사용하지 말고, 플래그에 따른 두 개의 함수를 만들라는 데에서 뒤통수를 얻어맞은 기분이었다. 왜 난 함수 하나로 두 개의 작업을 처리하는게 더 깔끔하다고 생각했을까?

위 규칙들을 다시 읽어보고 실제 코드에 적용해보며, 함수를 어떻게 짜야할지 고민해봐야겠다.

## ❓ 의문점
>  if/else/while 문 등에 들어가는 블록은 한 줄이어야 한다. (p.43)

규칙으로 적용하기에는 조금 과하다는 생각이 든다. 이런식으로 한 블록의 크기를 줄이는데 너무 집중하다보면, 코드 전체의 길이가 지나치게 길어질 수 있지 않을까?

**추상화 수준**이라는 용어가 어떤 느낌인지는 알겠는데, 명확히 이해되지 않는다. 따로 공부해봐야 할 것 같다.

함수가 **한 가지**만을 수행해야 한다는 부분에서는 아직 의문이 남는다. 물론 함수가 지나치게 많은 작업을 한꺼번에 처리하지 않아야 한다는 것은 명확하지만, 함수 하나에 하나의 일만을 할당하려다 너무 많은 함수를 만들어 버릴 수 있지 않을까?

심지어 이렇게 만든 함수들이 각각 한 줄 정도의 실행문을 가지고 있다면, 이들을 함수로 만드는 것이 과연 의미가 있을까?

다른 사람들의 의견을 참고하거나, 실제로 작성된 좋은 코드들을 보며 이 부분에 대한 검증을 해보고 싶다.


### 태그
---
#TIL #클린코드 