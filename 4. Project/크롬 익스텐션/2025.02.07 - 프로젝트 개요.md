
팝업 창은 사용자와 상호작용할 때만 활성화되고, 닫히면 그 안의 자바스크립트 실행도 중단되기 때문에(즉, 팝업은 "일시적"임), 타이머를 계속 실행하려면 별도의 **백그라운드 환경**에서 타이머 로직을 처리해야 함. Manifest V3에서는 백그라운드 스크립트가 **서비스 워커** 형태로 구현되며, 평소에는 완전히 "상태 유지"를 하지 않더라도, **chrome.alarms API**를 활용하면 필요한 시점에 다시 깨어나서 작업을 수행할 수 있어.

아래는 이를 어떻게 구현할지에 대한 개념적인 설명이야:

1. **타이머 상태 저장 및 관리**
    
    - 타이머가 시작되면 **타이머의 종료 시각(혹은 시작 시각과 지속 시간)**을 `localStorage`나 `chrome.storage`에 저장해.
    - 이렇게 저장해두면, 팝업이 닫히더라도 나중에 열었을 때 현재 남은 시간 등을 복원할 수 있어.
2. **백그라운드 서비스 워커(Background Service Worker) 사용**
    
    - Manifest V3의 백그라운드 스크립트(서비스 워커)는 팝업과 달리 사용자 인터페이스와 별도로 동작하는 환경이야.
    - 하지만 서비스 워커는 **항상 상주하지 않고, 필요할 때 깨워진 후 작업을 수행**하기 때문에, 장기간 연속 실행하는 타이머 코드를 단순하게 setInterval 등으로 구현하는 건 어려울 수 있어.
3. **chrome.alarms API 활용**
    
    - **chrome.alarms**를 사용하면 특정 시간(예: 타이머 종료 시점)에 **알람 이벤트**를 예약할 수 있어.
    - 타이머가 시작될 때 백그라운드 서비스 워커에서 해당 종료 시각에 맞춰 알람을 생성하고, 알람이 발생하면 서비스 워커가 깨어나서 처리(예: 타이머 종료 알림 전송, chrome.notifications API를 통해 사용자에게 알림 전달)를 수행하게 할 수 있어.
4. **알림(Notification) API 사용**
    
    - 타이머 종료 시점에 **chrome.notifications API**를 사용해서 사용자에게 알림을 보낼 수 있어.
    - 이렇게 하면 팝업이 열려 있지 않더라도 백그라운드에서 알림을 보내 사용자에게 타이머 종료를 알려줄 수 있어.
5. **팝업과 백그라운드 간의 메시지 통신**
    
    - 사용자가 팝업을 열었을 때, 백그라운드에 저장된 타이머의 상태(예: 종료 시각)를 읽어와서 현재 남은 시간을 계산할 수 있도록, **메시지 전달 방식**(chrome.runtime.sendMessage 또는 chrome.runtime.onMessage)을 활용할 수 있어.
    - 이렇게 하면 팝업이 열릴 때마다 최신 타이머 상태를 반영할 수 있어.

**요약하면:**

- 타이머를 팝업이 아닌 **백그라운드(서비스 워커)**에서 관리하고, 타이머 시작 시 종료 시각을 저장한 후 **chrome.alarms API**를 사용해 해당 시간에 알람 이벤트를 예약한다.
- 알람 이벤트가 발생하면, 백그라운드 스크립트가 깨어나서 **chrome.notifications API**로 사용자에게 알림을 보내거나 필요한 작업(예: 상태 갱신)을 수행한다.
- 팝업이 열릴 때는 백그라운드에 저장된 타이머 종료 시각과 현재 시간을 비교해 남은 시간을 계산하여 표시하도록 한다.

이런 방식으로 구현하면, 팝업이 닫혀 있어도 타이머는 계속 "백그라운드"에서 동작하고, 필요할 때 알림을 줄 수 있게 돼.